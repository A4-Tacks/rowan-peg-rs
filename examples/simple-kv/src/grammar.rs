// Generated by rowan-peg, do not edit it
use rowan::{ast::{support, AstChildren, AstNode}, Language};

macro_rules! decl_ast_node {
    ($node:ident, $kind:ident) => {
        #[derive(Debug, Clone, PartialEq, Eq, Hash)]
        pub struct $node(SyntaxNode);
        impl AstNode for $node {
            type Language = Lang;

            fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
                &self.0
            }

            fn can_cast(kind: <Self::Language as Language>::Kind) -> bool {
                kind == SyntaxKind::$kind
            }

            fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
                if Self::can_cast(node.kind()) {
                    Some(Self(node))
                } else {
                    None
                }
            }
        }
        impl core::fmt::Display for $node {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Display::fmt(self.syntax(), f)
            }
        }
    };
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Lang {}
impl Language for Lang {
    type Kind = SyntaxKind;

    fn kind_to_raw(kind: Self::Kind) -> ::rowan::SyntaxKind {
        kind.into()
    }

    fn kind_from_raw(raw: ::rowan::SyntaxKind) -> Self::Kind {
        raw.into()
    }
}

pub type SyntaxNode = ::rowan::SyntaxNode<Lang>;
pub type SyntaxToken = ::rowan::SyntaxToken<Lang>;

::peg::parser!(pub grammar parser<'b>(state: &'b ::rowan_peg_utils::ParseState<'input>) for str {
    use SyntaxKind::*;

    pub rule pair_list() = (g:({state.guard(PAIR_LIST)}) ((()(g:({state.guard_none()})(whitespace() (g:({state.guard_none()})(pair()){g.accept_none()})*){g.accept_none()}))) {g.accept()})
    rule pair() = (g:({state.guard(PAIR)}) ((()(g:({state.guard_none()})(key() whitespace() (g:({state.quiet().guard_token(EQ)}) s:$(("=")) {g.accept_token(s)}) whitespace() val() whitespace()){g.accept_none()}))) {g.accept()})
    rule key() = (g:({state.guard(KEY)}) ((()(g:({state.guard_none()})(text()){g.accept_none()}))) {g.accept()})
    rule val() = (g:({state.guard(VAL)}) ((()(g:({state.guard_none()})(number()){g.accept_none()}) / ()(g:({state.guard_none()})(text()){g.accept_none()}))) {g.accept()})
    rule number() = (g:({state.guard(NUMBER)}) ((()(g:({state.guard_none()})(int() (g:({state.guard_none()})((()(g:({state.guard_none()})((g:({state.quiet().guard_token(DOT)}) s:$((".")) {g.accept_token(s)}) int()){g.accept_none()}))){g.accept_none()})?){g.accept_none()}))) {g.accept()})
    rule int() = ()(()(g:({state.guard_none()})((g:({state.quiet().guard_token(INT)}) s:$(((()(g:({state.guard_none()})((g:({state.guard_none()})([::char_classes::any!(@"0-9")]){g.accept_none()})+){g.accept_none()})))) {g.accept_token(s)})){g.accept_none()}) / expected!("int"))
    rule text() = ()(()(g:({state.guard_none()})((g:({state.quiet().guard_token(TEXT)}) s:$(((()(g:({state.guard_none()})((g:({state.guard_none()})([::char_classes::any!(@"a-zA-Z_-")]){g.accept_none()})+){g.accept_none()})))) {g.accept_token(s)})){g.accept_none()}) / expected!("text"))
    rule whitespace() = ()(()(g:({state.guard_none()})((g:({state.quiet().guard_token(WHITESPACE)}) s:$(((()(g:({state.guard_none()})((g:({state.guard_none()})([::char_classes::any!(@" \t\r\n")]){g.accept_none()})*){g.accept_none()})))) {g.accept_token(s)})){g.accept_none()}))
});
#[repr(u16)]
#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum SyntaxKind {
    PAIR_LIST = 0,
    PAIR,
    EQ,
    KEY,
    VAL,
    NUMBER,
    DOT,
    INT,
    TEXT,
    WHITESPACE,
}
impl From<::rowan::SyntaxKind> for SyntaxKind { fn from(kind: ::rowan::SyntaxKind) -> Self { ::core::assert!(kind.0 <= Self::WHITESPACE as u16); unsafe { ::core::mem::transmute::<u16, SyntaxKind>(kind.0) } } }
impl From<SyntaxKind> for ::rowan::SyntaxKind { fn from(kind: SyntaxKind) -> Self { ::rowan::SyntaxKind(kind as u16) } }
decl_ast_node!(PairList, PAIR_LIST);
impl PairList {
    pub fn pairs(&self) -> AstChildren<Pair> {
        support::children(self.syntax())
    }
    pub fn whitespace(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::WHITESPACE).unwrap()
    }
}
decl_ast_node!(Pair, PAIR);
impl Pair {
    pub fn eq(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::EQ).unwrap()
    }
    pub fn key(&self) -> Key {
        support::child(self.syntax()).unwrap()
    }
    pub fn val(&self) -> Val {
        support::child(self.syntax()).unwrap()
    }
}
decl_ast_node!(Key, KEY);
impl Key {
    pub fn text(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::TEXT).unwrap()
    }
}
decl_ast_node!(Val, VAL);
impl Val {
    pub fn number(&self) -> Option<Number> {
        support::child(self.syntax())
    }
    pub fn text(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::TEXT)
    }
}
decl_ast_node!(Number, NUMBER);
impl Number {
    pub fn dot(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::DOT)
    }
}

