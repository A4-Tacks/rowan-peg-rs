// Generated by rowan-peg, do not edit it
use rowan::{ast::{support, AstChildren, AstNode}, Language};

macro_rules! decl_ast_node {
    ($node:ident, $kind:ident $(, #[$meta:meta])?) => {
        $(#[$meta])?
        #[derive(Debug, Clone, PartialEq, Eq, Hash)]
        pub struct $node(SyntaxNode);
        impl AstNode for $node {
            type Language = Lang;

            fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
                &self.0
            }

            fn can_cast(kind: <Self::Language as Language>::Kind) -> bool {
                kind == SyntaxKind::$kind
            }

            fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
                if Self::can_cast(node.kind()) {
                    Some(Self(node))
                } else {
                    None
                }
            }
        }
        impl core::fmt::Display for $node {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Display::fmt(self.syntax(), f)
            }
        }
    };
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Lang {}
impl Language for Lang {
    type Kind = SyntaxKind;

    fn kind_to_raw(kind: Self::Kind) -> ::rowan::SyntaxKind {
        kind.into()
    }

    fn kind_from_raw(raw: ::rowan::SyntaxKind) -> Self::Kind {
        raw.into()
    }
}

pub type SyntaxNode = ::rowan::SyntaxNode<Lang>;
pub type SyntaxToken = ::rowan::SyntaxToken<Lang>;

::peg::parser!(pub grammar parser<'b>(state: &'b ::rowan_peg_utils::ParseState<'input>) for str {
    use SyntaxKind::*;

    rule comment() = ()(()(g:({state.guard_none()})((g:({state.quiet().guard_token(COMMENT)}) s:$(((()(g:({state.guard_none()})(";" (g:({state.guard_none()})((quiet!{[^::char_classes::any!(@"\n")]}/expected!("<^\\n>"))){g.accept_none()})*){g.accept_none()})))) {g.accept_token(s)})){g.accept_none()}) / expected!("comment"))
    rule whitespace() = ()(()(g:({state.guard_none()})((g:({state.quiet().guard_token(WHITESPACE)}) s:$(((()(g:({state.guard_none()})((g:({state.guard_none()})((quiet!{[::char_classes::any!(@" \t\r\n")]}/expected!("< \\t\\r\\n>"))){g.accept_none()})*){g.accept_none()})))) {g.accept_token(s)})){g.accept_none()}))
    pub rule trivia() = _
    rule _() = (g:({state.guard(TRIVIA)}) ((()(g:({state.guard_none()})(whitespace() (g:({state.guard_none()})((()(g:({state.guard_none()})(comment() whitespace()){g.accept_none()}))){g.accept_none()})*){g.accept_none()}))) {g.accept()})
    rule ident() = ()(()(g:({state.guard_none()})((g:({state.quiet().guard_token(IDENT)}) s:$(((()(g:({state.guard_none()})(!(g:({state.quiet().guard_none()}) (quiet!{(quiet!{[::char_classes::any!(@"0-9")]}/expected!("<0-9>"))}) {g.accept_none()}) (g:({state.guard_none()})((()(g:({state.guard_none()})((quiet!{[::char_classes::any!(@"0-9a-zA-Z_-")]}/expected!("<0-9a-zA-Z_->"))){g.accept_none()}) / ()(g:({state.guard_none()})((quiet!{[^::char_classes::any!(@"\u{00}-\u{a0}")]}/expected!("<^\\u{00}-\\u{a0}>"))){g.accept_none()}))){g.accept_none()})+){g.accept_none()})))) {g.accept_token(s)})){g.accept_none()}) / expected!("ident"))
    rule number() = ()(()(g:({state.guard_none()})((g:({state.quiet().guard_token(NUMBER)}) s:$(((()(g:({state.guard_none()})((g:({state.guard_none()})((quiet!{[::char_classes::any!(@"0-9")]}/expected!("<0-9>"))){g.accept_none()})+){g.accept_none()})))) {g.accept_token(s)})){g.accept_none()}) / expected!("number"))
    rule string() = ()(()(g:({state.guard_none()})((g:({state.quiet().guard_token(STRING)}) s:$(((()(g:({state.guard_none()})("\"" (g:({state.guard_none()})((quiet!{[^::char_classes::any!(@"\"\r\n")]}/expected!("<^\\\"\\r\\n>"))){g.accept_none()})* "\""){g.accept_none()})))) {g.accept_token(s)})){g.accept_none()}) / expected!("string"))
    rule matches() = ()(()(g:({state.guard_none()})((g:({state.quiet().guard_token(MATCHES)}) s:$(((()(g:({state.guard_none()})("<" (g:({state.guard_none()})((quiet!{[^::char_classes::any!(@"\x3e\r\n")]}/expected!("<^\\x3e\\r\\n>"))){g.accept_none()})* ">"){g.accept_none()})))) {g.accept_token(s)})){g.accept_none()}) / expected!("matches"))
    rule label() = (g:({state.guard(LABEL)}) ((()(g:({state.guard_none()})(ident()){g.accept_none()}) / ()(g:({state.guard_none()})(string()){g.accept_none()}))) {g.accept()})
    rule repeat_rest() = (g:({state.guard(REPEAT_REST)}) ((()(g:({state.guard_none()})((g:({state.quiet().guard_token(STAR)}) s:$(("*")) {g.accept_token(s)}) (g:({state.guard_none()})((()(g:({state.guard_none()})(number()){g.accept_none()}))){g.accept_none()})?){g.accept_none()}))) {g.accept()})
    rule repeat() = (g:({state.guard(REPEAT)}) ((()(g:({state.guard_none()})((g:({state.quiet().guard_token(PLUS)}) s:$(("+")) {g.accept_token(s)})){g.accept_none()}) / ()(g:({state.guard_none()})(number() (g:({state.guard_none()})((()(g:({state.guard_none()})(repeat_rest()){g.accept_none()}))){g.accept_none()})?){g.accept_none()}) / ()(g:({state.guard_none()})(repeat_rest()){g.accept_none()}))) {g.accept()})
    rule pat_expect() = (g:({state.guard(PAT_EXPECT)}) ((()(g:({state.guard_none()})((g:({state.quiet().guard_token(AT)}) s:$(("@")) {g.accept_token(s)}) label()){g.accept_none()}))) {g.accept()})
    rule pat_atom() = (g:({state.guard(PAT_ATOM)}) ((()(g:({state.guard_none()})(ident() !(g:({state.quiet().guard_none()}) (quiet!{(()(g:({state.guard_none()})(_() (g:({state.quiet().guard_token(EQ)}) s:$(("=")) {g.accept_token(s)})){g.accept_none()}))}) {g.accept_none()})){g.accept_none()}) / ()(g:({state.guard_none()})(string()){g.accept_none()}) / ()(g:({state.guard_none()})(matches()){g.accept_none()}) / ()(g:({state.guard_none()})((g:({state.quiet().guard_token(L_BRACK)}) s:$(("[")) {g.accept_token(s)}) _() pat_choice() _() (g:({state.quiet().guard_token(R_BRACK)}) s:$(("]")) {g.accept_token(s)})){g.accept_none()}) / ()(g:({state.guard_none()})((g:({state.quiet().guard_token(L_PAREN)}) s:$(("(")) {g.accept_token(s)}) _() pat_choice() _() (g:({state.quiet().guard_token(R_PAREN)}) s:$((")")) {g.accept_token(s)})){g.accept_none()}))) {g.accept()})
    rule pat_op() = (g:({state.guard(PAT_OP)}) ((()(g:({state.guard_none()})((g:({state.quiet().guard_token(AMP)}) s:$(("&")) {g.accept_token(s)}) pat_atom()){g.accept_none()}) / ()(g:({state.guard_none()})((g:({state.quiet().guard_token(BANG)}) s:$(("!")) {g.accept_token(s)}) pat_atom()){g.accept_none()}) / ()(g:({state.guard_none()})((g:({state.quiet().guard_token(TILDE)}) s:$(("~")) {g.accept_token(s)}) pat_atom()){g.accept_none()}) / ()(g:({state.guard_none()})((g:({state.quiet().guard_token(DOLLAR)}) s:$(("$")) {g.accept_token(s)}) pat_atom()){g.accept_none()}) / ()(g:({state.guard_none()})(repeat() _() pat_atom()){g.accept_none()}) / ()(g:({state.guard_none()})(pat_atom()){g.accept_none()}))) {g.accept()})
    rule pat_list() = (g:({state.guard(PAT_LIST)}) ((()(g:({state.guard_none()})(pat_op() (g:({state.guard_none()})((()(g:({state.guard_none()})(_() pat_op()){g.accept_none()}))){g.accept_none()})*){g.accept_none()}))) {g.accept()})
    rule pat_choice() = (g:({state.guard(PAT_CHOICE)}) ((()(g:({state.guard_none()})(pat_list() (g:({state.guard_none()})((()(g:({state.guard_none()})(_() (g:({state.quiet().guard_token(SLASH)}) s:$(("/")) {g.accept_token(s)}) _() pat_list()){g.accept_none()}))){g.accept_none()})* (g:({state.guard_none()})((()(g:({state.guard_none()})(_() pat_expect()){g.accept_none()}))){g.accept_none()})?){g.accept_none()}))) {g.accept()})
    rule named() = (g:({state.guard(NAMED)}) ((()(g:({state.guard_none()})(ident() _() (g:({state.quiet().guard_token(EQ)}) s:$(("=")) {g.accept_token(s)}) _()){g.accept_none()}))) {g.accept()})
    rule decl() = (g:({state.guard(DECL)}) ((()(g:({state.guard_none()})(named() pat_choice()){g.accept_none()}))) {g.accept()})
    rule export() = (g:({state.guard(EXPORT)}) ((()(g:({state.guard_none()})((g:({state.guard_none()})((()(g:({state.guard_none()})(named()){g.accept_none()}))){g.accept_none()})? ident()){g.accept_none()}))) {g.accept()})
    rule export_list() = (g:({state.guard(EXPORT_LIST)}) ((()(g:({state.guard_none()})((g:({state.quiet().guard_token(EXPORTS_KW)}) s:$(("exports")) {g.accept_token(s)}) _() (g:({state.quiet().guard_token(L_BRACK)}) s:$(("[")) {g.accept_token(s)}) _() (g:({state.guard_none()})((()(g:({state.guard_none()})(export() _()){g.accept_none()}))){g.accept_none()})* (g:({state.quiet().guard_token(R_BRACK)}) s:$(("]")) {g.accept_token(s)})){g.accept_none()}))) {g.accept()})
    pub rule decl_list() = (g:({state.guard(DECL_LIST)}) ((()(g:({state.guard_none()})(_() (g:({state.guard_none()})((()(g:({state.guard_none()})(export_list() _()){g.accept_none()}))){g.accept_none()})? (g:({state.guard_none()})((()(g:({state.guard_none()})(decl() _()){g.accept_none()}))){g.accept_none()})+){g.accept_none()}))) {g.accept()})
});
#[repr(u16)]
#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum SyntaxKind {
    COMMENT = 0,
    WHITESPACE,
    TRIVIA,
    IDENT,
    NUMBER,
    STRING,
    MATCHES,
    LABEL,
    REPEAT_REST,
    STAR,
    REPEAT,
    PLUS,
    PAT_EXPECT,
    AT,
    PAT_ATOM,
    L_PAREN,
    R_PAREN,
    PAT_OP,
    AMP,
    BANG,
    TILDE,
    DOLLAR,
    PAT_LIST,
    PAT_CHOICE,
    SLASH,
    NAMED,
    EQ,
    DECL,
    EXPORT,
    EXPORT_LIST,
    EXPORTS_KW,
    L_BRACK,
    R_BRACK,
    DECL_LIST,
}
impl From<::rowan::SyntaxKind> for SyntaxKind { fn from(kind: ::rowan::SyntaxKind) -> Self { ::core::assert!(kind.0 <= Self::DECL_LIST as u16); unsafe { ::core::mem::transmute::<u16, SyntaxKind>(kind.0) } } }
impl From<SyntaxKind> for ::rowan::SyntaxKind { fn from(kind: SyntaxKind) -> Self { ::rowan::SyntaxKind(kind as u16) } }
decl_ast_node!(Trivia, TRIVIA, #[doc = "```abnf\n_           = whitespace *(comment whitespace)\n```"]);
impl Trivia {
    pub fn comment_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        ::rowan_peg_utils::tokens(self.syntax(), SyntaxKind::COMMENT)
    }
    pub fn whitespace_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        ::rowan_peg_utils::tokens(self.syntax(), SyntaxKind::WHITESPACE)
    }
}
decl_ast_node!(Label, LABEL, #[doc = "```abnf\nlabel       = ident / string\n```"]);
impl Label {
    pub fn ident(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::IDENT)
    }
    pub fn string(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::STRING)
    }
}
decl_ast_node!(RepeatRest, REPEAT_REST, #[doc = "```abnf\nrepeat-rest = \"*\" [number]\n```"]);
impl RepeatRest {
    pub fn number(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::NUMBER)
    }
    /// Get star `*`
    #[doc(alias = "*")]
    pub fn star(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::STAR).unwrap()
    }
}
decl_ast_node!(Repeat, REPEAT, #[doc = "```abnf\nrepeat      = \"+\"\n            / number [repeat-rest]\n            / repeat-rest\n```"]);
impl Repeat {
    pub fn number(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::NUMBER)
    }
    /// Get plus `+`
    #[doc(alias = "+")]
    pub fn plus(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::PLUS)
    }
    pub fn repeat_rest(&self) -> Option<RepeatRest> {
        support::child(self.syntax())
    }
}
decl_ast_node!(PatExpect, PAT_EXPECT, #[doc = "```abnf\npat-expect  = \"@\" label\n```"]);
impl PatExpect {
    /// Get at `@`
    #[doc(alias = "@")]
    pub fn at(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::AT).unwrap()
    }
    pub fn label(&self) -> Label {
        support::child(self.syntax()).unwrap()
    }
}
decl_ast_node!(PatAtom, PAT_ATOM, #[doc = "```abnf\npat-atom    = ident !(_ \"=\")            ; a rule reference\n            / string                    ; keyword\n            / matches                   ; char classes\n            / \"[\" _ pat-choice _ \"]\"    ; optional\n            / \"(\" _ pat-choice _ \")\"\n```"]);
impl PatAtom {
    pub fn ident(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::IDENT)
    }
    /// Get l brack `[`
    #[doc(alias = "[")]
    pub fn l_brack(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::L_BRACK)
    }
    /// Get l paren `(`
    #[doc(alias = "(")]
    pub fn l_paren(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::L_PAREN)
    }
    pub fn matches(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::MATCHES)
    }
    pub fn pat_choice(&self) -> Option<PatChoice> {
        support::child(self.syntax())
    }
    /// Get r brack `]`
    #[doc(alias = "]")]
    pub fn r_brack(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::R_BRACK)
    }
    /// Get r paren `)`
    #[doc(alias = ")")]
    pub fn r_paren(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::R_PAREN)
    }
    pub fn string(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::STRING)
    }
    pub fn trivias(&self) -> AstChildren<Trivia> {
        support::children(self.syntax())
    }
}
decl_ast_node!(PatOp, PAT_OP, #[doc = "```abnf\npat-op      = \"&\" pat-atom ; positive lookahead\n            / \"!\" pat-atom ; negative lookahead\n            / \"~\" pat-atom ; quiet\n            / \"$\" pat-atom ; slice\n            / repeat _ pat-atom\n            / pat-atom\n```"]);
impl PatOp {
    /// Get amp `&`
    #[doc(alias = "&")]
    pub fn amp(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::AMP)
    }
    /// Get bang `!`
    #[doc(alias = "!")]
    pub fn bang(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::BANG)
    }
    /// Get dollar `$`
    #[doc(alias = "$")]
    pub fn dollar(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::DOLLAR)
    }
    pub fn pat_atom(&self) -> PatAtom {
        support::child(self.syntax()).unwrap()
    }
    pub fn repeat(&self) -> Option<Repeat> {
        support::child(self.syntax())
    }
    /// Get tilde `~`
    #[doc(alias = "~")]
    pub fn tilde(&self) -> Option<SyntaxToken> {
        support::token(self.syntax(), SyntaxKind::TILDE)
    }
    pub fn trivia(&self) -> Option<Trivia> {
        support::child(self.syntax())
    }
}
decl_ast_node!(PatList, PAT_LIST, #[doc = "```abnf\npat-list    = pat-op *(_ pat-op)\n```"]);
impl PatList {
    pub fn pat_ops(&self) -> AstChildren<PatOp> {
        support::children(self.syntax())
    }
    pub fn trivias(&self) -> AstChildren<Trivia> {
        support::children(self.syntax())
    }
}
decl_ast_node!(PatChoice, PAT_CHOICE, #[doc = "```abnf\npat-choice  = pat-list *(_ \"/\" _ pat-list)\n              [_ pat-expect]\n```"]);
impl PatChoice {
    pub fn pat_expect(&self) -> Option<PatExpect> {
        support::child(self.syntax())
    }
    pub fn pat_lists(&self) -> AstChildren<PatList> {
        support::children(self.syntax())
    }
    /// Get slash `/`
    #[doc(alias = "/")]
    pub fn slash_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        ::rowan_peg_utils::tokens(self.syntax(), SyntaxKind::SLASH)
    }
    pub fn trivias(&self) -> AstChildren<Trivia> {
        support::children(self.syntax())
    }
}
decl_ast_node!(Named, NAMED, #[doc = "```abnf\nnamed       = ident _ \"=\" _\n```"]);
impl Named {
    /// Get eq `=`
    #[doc(alias = "=")]
    pub fn eq(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::EQ).unwrap()
    }
    pub fn ident(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::IDENT).unwrap()
    }
    pub fn trivias(&self) -> AstChildren<Trivia> {
        support::children(self.syntax())
    }
}
decl_ast_node!(Decl, DECL, #[doc = "```abnf\ndecl        = named pat-choice\n```"]);
impl Decl {
    pub fn named(&self) -> Named {
        support::child(self.syntax()).unwrap()
    }
    pub fn pat_choice(&self) -> PatChoice {
        support::child(self.syntax()).unwrap()
    }
}
decl_ast_node!(Export, EXPORT, #[doc = "```abnf\nexport      = [named] ident\n```"]);
impl Export {
    pub fn ident(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::IDENT).unwrap()
    }
    pub fn named(&self) -> Option<Named> {
        support::child(self.syntax())
    }
}
decl_ast_node!(ExportList, EXPORT_LIST, #[doc = "```abnf\nexport-list = \"exports\" _ \"[\" _ *(export _) \"]\"\n```"]);
impl ExportList {
    pub fn exports(&self) -> AstChildren<Export> {
        support::children(self.syntax())
    }
    pub fn exports_kw(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::EXPORTS_KW).unwrap()
    }
    /// Get l brack `[`
    #[doc(alias = "[")]
    pub fn l_brack(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::L_BRACK).unwrap()
    }
    /// Get r brack `]`
    #[doc(alias = "]")]
    pub fn r_brack(&self) -> SyntaxToken {
        support::token(self.syntax(), SyntaxKind::R_BRACK).unwrap()
    }
    pub fn trivias(&self) -> AstChildren<Trivia> {
        support::children(self.syntax())
    }
}
decl_ast_node!(DeclList, DECL_LIST, #[doc = "```abnf\ndecl-list   = _ [export-list _] +(decl _)\n```"]);
impl DeclList {
    pub fn decls(&self) -> AstChildren<Decl> {
        support::children(self.syntax())
    }
    pub fn export_list(&self) -> Option<ExportList> {
        support::child(self.syntax())
    }
    pub fn trivias(&self) -> AstChildren<Trivia> {
        support::children(self.syntax())
    }
}

